스마트 컨트랙트 배포:

스마트 컨트랙트를 배포한다는 것은 컴파일된 EVM 코드를 하나의 트랜잭션 처럼 블록에 추가시켜 블록체인에 등록시키는 작업입니다.
소스 컴파일 -> EVM 바이트 코드 -> 구체적인 작업은 ABI 취득 -> ABI로부터 컨트랙트 객체 생성 -> 트랜잭션 생성하여 블록에 추가
마이너가 해당 블록을 채굴하게 되면 블록체인에 포함됨.

---

ABI 취득이란 

1) 스마트 컨트랙트를 컴파일 하면 `바이트코드` 와 `ABI` 등이 생성된다
`ABI`는 스마트 컨트랙트의 바이트 코드를, 일반 프로그램에서 호출하고 실행시킬 수 있는 정보와 인터페이스를 제공한다.

2) 개발자는 스마트 컨트랙트 주소와 ABI를 알면 web3.JS를 통해 스마트 컨트랙트를 생성하고 특정 함수를 실행 할 수 있다.

---
탭루트는 어떻게 비트코인에 도움이 될까요?

이미 논의한 바와 같이 탭루트는 비트코인의 프라이버시를 크게 향상시킬 것입니다. 탭루트는 슈노르 서명과 함께 트랜잭션 진행 효율성을 높일 수도 있습니다. 프라이버시를 향상시키는 것 이외에도 다음과 같은 장점이 존재합니다.

1) 블록체인상에서 전송 및 저장해야 하는 데이터 양의 감소

2) 블록 당 더 많은 트랜잭션 처리(더 높은 TPS 비율)
 
4) 보다 저렴한 트랜잭션 수수료

---

[프루닝 이란](https://www.youtube.com/watch?v=-Zjev82LSzU)

[SPV 와 블룸필터](https://www.youtube.com/watch?v=xdv10uKTnJ4)

[DAG란 무엇인가?](https://steemit.com/dag/@cryptodreamers/dag-dag-directed-acyclic-graph)


---

암호 해시 함수

암호 해시 함수의 안전성을 평가하는 요소를 다음 세가지로 볼 수 있다.

1) 충돌 저항성 : 서로 다른 입력값이 동일한 출력값을 갖게 되는 것
   
2) 역상 저항성 : 어떤 해시 함수가 특정한 값을 출력하는 입력값을 찾을 확률 
   - 단방향 함수는 
     - `입력 값 => 출력 값` 가능
     - ` 출력 값 => 입력 값` 불가능

3) 제2 역상 저항성 : 
   - 충돌 가능성은 동일한 해시값을 가진 서로 다른 두 입력값을 찾는 것이지만, 제2 역상 공격은 A 입력값을 통해 A' 라는 해시값이 나왔을 때, A' 해시값을 출력하게 만드는 B 입력값을 찾는 것입니다.

---

디지털 서명은 크게 해싱, 서명, 검증 세 단계로 나뉩니다.
![암호화 기술과 보안&서명(Signature)-그림.5](https://cdn.discordapp.com/attachments/952955895703289867/952955935574331432/Px7GLgXlBgdUNOFSOxvSn-1636273319485.png) 디지털 서명 방식

---

디지털 서명은 세 가지 특징을 가지고 있습니다.

1) 데이터 무결성
- 수신자는 메시지가 전송되는 동안 위변조가 일어나지 않았음을 검증할 수 있습니다. 만약 송신자의 공개 키로 디지털 서명을 복호화 한 값이 원본 데이터를 해싱한 값과 다른 경우, 해당 송신자의 개인 키로 암호화된 서명이 아니거나, 원본 데이터가 훼손되었을 수 있습니다.

2) 진위성
 - 송신자의 개인 키가 안전하게 보관되었다는 전제 하에, 수신자는 디지털 서명이 송신자에 의해 생성되었음을 확인할 수 있습니다.

3) 부인 방지
- 송신자의 개인 키가 안전하게 보관되었다는 전제 하에, 서명이 생성되고 나면 이 서명이 송신자에 의해 서명되었다는 사실을 부정할 수 없습니다.

---

공개 키 암호 방식의 장단점

- 공개 키 암호 방식은 기존의 대칭 키 암호 방식이 가졌던 키 노출 문제를 해결하여 컴퓨터 보안을 강화하며, 데이터의 무결성을 확인하는 데 사용할 수도 있습니다.

- 암호화 및 복호화의 수학적 계산이 매우 복잡하기 때문에, 대량의 데이터를 처리할 경우 오버헤드가 발생하여 속도가 느려질 수 있습니다. 
 
- 또한 대칭 키 암호 방식과 마찬가지로, 개인 키가 안전하지 않은 공간에 노출되는 경우, 대응하는 공개 키로 암호화된 모든 데이터의 보안이 위협받게 됩니다.

---

## 공개 키 암호 방식과 대칭 키 암호 방식의 비교

### 1. 키의 길이
대칭 키 암호화 알고리즘은 키의 길이가 임의로 지정되며, 보안 수준에 따라 128 비트나 256 비트로 설정됩니다.
반면, 공개 키 암호화 알고리즘은 공개 키와 비밀 키가 수학적으로 한 쌍을 이루어야 하기 때문에 수학적 패턴을 가지고 있습니다. 어떠한 패턴을 가졌다는 것은 곧 공격자에 의해 패턴이 간파될 수 있다는 것을 의미합니다. 따라서 공개 키 암호 방식 알고리즘은 대칭 키 방식과 동등한 수준의 보안을 제공하기 위해 훨씬 더 긴 키를 사용합니다. 일반적으로 128비트의 대칭 키와 2,048 비트의 공개 키가 비슷한 수준의 보안을 제공합니다.

### 2. 연산 속도
대칭 키 암호 방식에 사용되는 블록 암호화나 스트림 암호화 모두 연산이 단순하기 때문에 연산 속도가 빠릅니다. 따라서 대용량 데이터를 전송해야 할 때 많이 사용합니다.
반면, 공개 키 암호 방식의 경우, 복잡한 수학적 연산을 수행해야 하기 때문에 비교적 속도가 느리며, 키 길이가 길기 때문에 훨씬 더 많은 연산 능력을 필요로 합니다. 주로 데이터 전송에 앞서 안전한 통신 채널을 인증하고 구축하기 위한 소규모 트랜잭션(ex. TLS)에 많이 사용됩니다.

### 3. 보안
대칭 키 암호 방식에서는 단일한 비밀 키를 공유해야 하기 때문에, 키 노출 시 보안 위협이 큽니다.
반면, 공개 키 암호 방식의 경우, 암호화 할 때 공개 키를 사용하고, 복호화 할 때는 개인 키를 사용하여 이러한 문제를 해결합니다.

### 4. 알고리즘
잘 알려진 대칭 키 암호 방식 알고리즘에는 RC4, AES, DES, 3DES 등이 있으며, 공개 키 암호 방식 알고리즘에는 RSA, 디피-헬먼, ECC 등이 있습니다.

---

## ECDSA

ECDSA(Elliptic Curve Digital Signature Algorithm; 타원곡선 디지털서명 알고리즘)은 공개키 방식 중 하나인 ECC(Elliptic Curve Cryptography; 타원곡선암호)에 디지털 서명 방식을 접목한 알고리즘입니다.

## HMAC

HMAC은 Hash-based Message Authentication Code의 약자로, 대칭 키 암호 방식을 사용하여 디지털 서명을 구현합니다. HMAC은 송신자와 수신자가 단일 키를 공유하고, 해당 단일 키와 원본 데이터를 해싱한 값과 원본 데이터를 함께 트랜잭션으로 보내 데이터의 무결성을 증명합니다.

## PKI

PKI(Public Key Infrastructure, 공개 키 인프라)는 디지털 인증서와 공개 키를 생성, 관리, 배포, 사용, 저장 및 해지하는 데 필요한 일련의 하드웨어, 소프트웨어, 정책, 프로세스와 절차의 집합입니다. PKI는 대규모 사용자 집단에서 디지털 서명 및 암호화와 같은 기술을 사용할 수 있는 기반입니다. PKI의 목적은 데이터를 안전하게 전송하는 것이며, 이를 위해 시스템 및 리소스 접근 권한, 데이터 보호, 트랜잭션 무결성 및 진위성, 기밀성을 보장합니다.

## 슈노르 서명

일반적인 디지털 서명에서는 공개 키, 서명할 메시지 및 서명이 포함되어 있으며 공개 키의 소유자가 주어진 메시지에 서명했음을 보여줍니다. 가령 멀티시그 주소에서 송금을 하는 등 여러 이해당사자가 하나의 메시지에 서명을 하기 원하는 경우, 각 이해당사자는 하나의 메시지에 서명과 공개 키를 포함해야 합니다. 만약 3명의 당사자가 동일한 메시지에 서명하기 원하는 경우, 3개의 공개키와 3개의 서명이 포함될 것입니다. 각 노드는 서명을 검증하는 과정을 3번 수행해야 하고, 블록은 3개의 공개키와 3개의 서명을 저장해야 하기 때문에 자리를 많이 차지하고 있습니다.

슈노르 서명에서는 키 집합(Key Aggregation)을 사용합니다. 슈노르 서명은 서명을 하는 당사자의 공개 키들을 결합하여 단일한 하나의 공개 키를 구성합니다. 그리고 각 당사자의 개인 키를 사용하여 해당 메시지에 서명을 할 수 있습니다. 또한 당사자들의 서명을 결합하여 합쳐진 단일 공개 키에 유효한 단일 서명을 구성할 수 있습니다. 검증 노드가 당사자들이 모두 메시지에 서명했는지 확인할 때는 단일 서명과 단일 공개키로 확인할 수 있습니다.

슈노르 서명은 당사자들의 정보를 하나로 통합하기 때문에 개인 정보 보호에 유리하며, 블록에 들어가는 멀티시그 공개 키들과 서명들의 크기를 일반적인 블록 크기 정도로 줄이기 때문에 블록 공간을 매우 절약하고, 검증의 속도를 빠르게 할 수 있습니다.

---

## CAP 요소
`분할 허용(P; Partition Tolerance)` : 여러 개의 네트워크가 동작하고 있을 때 접속이 단절되어 서로 메시지를 주고받지 못하더라도 서비스가 잘 동작해야 한다.

`일관성(C; Consistency)` : 분산 시스템에서의 요청 및 응답 과정에서, 노드가 여러 개 있더라도 마치 한 노드에서 실행되는 것처럼 동작해야 한다.

`가용성(A; Availability)` : 분산 시스템이 지속해서 가용하기 위해서 장애 없는(Non-Failing) 노드에 수신된 모든 요청은 반드시 응답돼야 한다.

## CAP의 상관관계
`CA`: 일관성과 가용성을 충족하지만 분할 허용을 충족하지 못한다. 데이터에 대한 강한 신뢰를 부여할 수 있지만, 네트워크 문제가 시스템의 중단을 야기할 수 있다.

`CP`: 일관성과 분할 허용을 충족하지만 가용성을 충족하지 못한다. 높은 확장성으로부터 성능을 확보할 수 있지만 일부 데이터가 비가용할 수 있다.

`AP`: 가용성과 분할 허용을 충족하지만 일관성을 충족하지 못한다. 부정확한 응답을 허용하는 고성능 시스템에 적합하다.

---

## 비결정적 지갑과 결정적 지갑

매번 비밀 키를 무작위로 생성하는 방식의 지갑을 `비결정적 지갑`이라고 합니다.

시드 키로부터 만들어지는 모든 비밀 키는 그 값이 미리 정해져 있다고 볼 수 있습니다. 따라서 시드 키를 이용한 지갑 방식을 `결정적 지갑(Deterministic Wallet)`이라고 합니다. 

## DRBG
 컴퓨터로 만든 난수를 해시함수를 통해 진짜 난수로 만드는 알고리즘을 DRBG(Deterministic Random Bits Generate)이라고 합니다

## 멀티 시그 월렛


---

## 블록체인의 보안적 특징

## 데이터 무결성
무결성은 데이터베이스가 데이터의 정확성과 일관성을 유지하는 것을 의미합니다.
블록체인에서는 합의 알고리즘을 사용해 데이터의 무결성을 보장합니다. 합의 알고리즘을 통해 블록에 입력된 데이터에 대해 분산된 각 노드들이 모두 동일한 결과를 가질 수 있도록 합니다. 만약 네트워크에
악의적인 노드가 참여하더라도, 합의를 통해 노드가 블록을 변조하지 못하도록 하여 전체 네트워크의 신뢰도를 감소시키지 않도록 합니다.
다시 말해, 합의 알고리즘은 네트워크 상에 존재하는 신뢰할 수 없는 노드들이 절차에 맞게 상호 검증하여 네트워크 전체의 무결성을 보장하는 알고리즘입니다.

## 거래 투명성

퍼블릭 블록체인의 경우, 누구나 블록체인 네트워크에 접속해 트랜잭션 기록을 확인할 수 있습니다. 프라이빗 블록체인도 허가된 사용자라면 누구나 트랜잭션 기록을 볼 수 있습니다.
거래 기록에 누구나 공개적으로 접근할 수 있기 때문에, 송금 과정을 투명하게 하기 위한 규제 비용을 절감할 수 있습니다.

## 감시 가능성

블록체인은 데이터 추가만 가능한(Append-Only) 데이터베이스로, 한번 블록이 체인에 올라가면 블록에 담겨있는 트랜잭션이나 데이터는 수정할 수 없습니다.
이 과정에 사용되는 핵심적인 기술이 바로 해시 알고리즘입니다. 새로 생성되는 블록의 헤더에는 이전 헤더의 해시 값이 포함되어 있기 때문에, 연결된 모든 블록의 무결성 검증에 사용됩니다.
그리고 블록에 담긴 트랜잭션을 나타내는 머클 트리의 루트 해시값이 블록 헤더에 함께 포함되어 있으며, 만약 트랜잭션에 변경이 일어나면 머클 해시 값이 변경되므로, 블록체인에 대한 위변조 시도를 바로 발견할 수 있습니다.

---

## 비트코인 이중 지불

### 1. 51% 공격
단일 주체나 조직이 50% 이상의 해시 레이트를 가지게 될 경우, 이들은 원치 않는 트랜잭션을 배제하거나 트랜잭션 순서를 조작할 수 있게 됩니다. 비트코인에서 해당 공격이 발생할 가능성은 매우 낮지만, 규모가 작은 다른 네트워크에서는 발생할 수도 있습니다.

### 2. 레이스 공격(Race Attacks)
동일한 자금을 사용하는 두 개의 충돌하는 트랜잭션이 연속으로 전송되지만, 하나의 트랜잭션만 승인되는 것입니다. 해당 공격의 목표는 앞의 패스트푸드점 예시처럼 두 개의 충돌하는 트랜잭션 중 자신에게 이익이 되는 트랜잭션만 유효하게 만들어 결제를 무효화하는 것입니다. 레이스 공격은 수신자가 체인에 올라가지 않은 트랜잭션을 결제로 수용할 때 가능합니다.

### 3. 핀니 공격(Finney Attacks) ????
공격자는 네트워크에 즉각적으로 트랜잭션을 전송하지 않고, 코인을 자신의 다른 지갑으로 전송하는 트랜잭션을 미리 생성해두고, 블록을 미리 채굴해두어 해당 블록에 기록합니다. 동일 코인을 다른 트랜잭션에서 사용하는 대신, 이전에 채굴한 블록만을 전송하며, 결제는 무효화됩니다. 핀니 공격은 특정한 순서에 따라 사건이 발생해야 하며, 수신자는 체인에 올라가지 않은 트랜잭션을 수용해야 발생 가능합니다.

[해시넷 - 피니 공격](http://wiki.hash.kr/index.php/%ED%94%BC%EB%8B%88_%EA%B3%B5%EA%B2%A9)

---

## 51% 공격
단일 주체나 조직이 50%가 넘는 해시 파워를 가지게 된다면 어떻게 될까요? 이를 통해 벌어질 수 있는 문제를 51% 공격이라 부르며, 이는 다수 공격(Majority Attack)으로도 불립니다.

--- 

## 리플레이 공격

리플레이 공격(Replay Attack)이란 공격자가 보안 네트워크 통신을 가로채고, 해당 통신의 수신자로 하여금 공격자가 원하는 일을 수행하도록 하기 위해 통신을 지연시키거나 재전송하는 방식입니다.

리플레이 공격은 해커가 네트워크에서 메시지를 가로챈 후 메시지를 복호화하기 위한 별도의 과정이 필요하지 않으며, 메시지를 포함한 통신 전체를 다시 전송하는 것으로도 공격을 성공할 수 있습니다.

    ex) 하드포크가 진행되면, 원장 데이터는 하드 포크 이전 버전과 이후 버전으로 나누어지게 됩니다. 하드포크가 진행되어 체인이 A와 B로 나누어졌다고 가정합시다. 하드 포크 이후 생겨난 B 체인에서 처리한 트랜잭션은, 이론적으로 A 체인에서도 유효하게 사용할 수 있습니다.

    따라서 A와 B에 모두 계정이 있는 사용자는 B에서 트랜잭션을 발생시켰을 때, A 체인에서 누군가가 해당 트랜잭션을 탈취해 브로드캐스팅하면 A 체인에서도 해당 트랜잭션이 처리됩니다.



## 리플레이 공격 대안
### 1) 세션 식별자 추가
통신 당사자 간 일회용 토큰을 해싱한 값을 공유하여 리플레이 어택을 피합니다.

앨리스가 밥에게 일회용 토큰을 보냅니다.

밥은 토큰을 암호화하여 앨리스에게 보냅니다.

앨리스는 밥과 동일한 방식으로 토큰을 암호화하고, 그 값이 밥으로부터 받은 값과 같은 경우, 통신을 진행합니다.

공격자가 이 암호화된 값을 가로채고 다른 통신에서 사용하려고 해도, 앨리스가 밥에게 다른 일회용 토큰을 보내면 다른 암호화된 값이 나올 것이기 때문에 공격자가 가로챈 값은 사용할 수 없게 됩니다.

### 2) 일회용 비밀번호
아주 짧은 세션 시간을 가진 비밀번호를 두 통신 당사자가 공유하여, 공격자가 가로채 재사용하지 못하도록 합니다.

### 3) 타임 스탬프
앨리스가 네트워크에 시간을 MAC와 함께 브로드캐스트합니다. 밥은 앨리스에게 통신을 요청할 때, 자신의 통신 메시지에 앨리스가 브로드캐스트한 시간을 기준으로 예상 시간을 포함시켜 인증을 진행합니다. 앨리스는 타임 스탬프가 예상 시간 범위 내에 있는 메시지만 수락합니다.

---
<br>
<br>
<br>

# 이클립스 공격
이클립스 공격은 전체 네트워크를 공격하기 보다는 특정 노드를 격리시켜 정직한 다른 노드로부터 정보를 수신받지 못하게 여러 악의적인 공격자 노드가 네트워크를 독점합니다. 이 공격 노드들은 가짜 트랜잭션이 담긴 블록을 격리한 노드들에게 브로드캐스트하여 이중 지불 공격을 가능하도록 만듭니다.


## 이클립스 공격 동작방식
블록체인에서 노드는 다른 노드들과 동시적으로 연결될 수 없으며, 대신 제한된 인접 노드들과 연결되어 있습니다. 노드들이 데이터를 공유할 때는 모두가 동시에 공유하는 것이 아니라, 하나의 노드에서 주변 노드로 점점 퍼져나가는 브로드캐스트 방식을 사용합니다.

공격자는 공격 대상의 이웃 노드들을 자신의 노드로 구성하여, 공격 대상 노드가 가짜 트랜잭션이 담긴 블록을 받도록 합니다.

이를 통해 다음과 같은 공격 효과가 발생합니다.


## 엔지니어링 블록 레이스(Engineering Block Races)
블록 레이스는 채굴 노드들이 가장 먼저 유효한 논스 값을 찾아 블록을 생성하는 경쟁을 의미합니다. 이클립스 공격에서는 이클립스 공격 대상 노드와 공격자의 노드가 동시에 블록을 생성한 경우, 공격 대상 노드가 생성한 블록을 숨김으로써 해당 블록은 고아 블록이 되고, 자신의 블록이 네트워크에 올라갈 수 있도록 합니다.


## 채굴 파워 분할(Splitting Mining Power)
공격자가 51% 공격을 하기 위해 네트워크의 전체 채굴 파워를 쪼갤 수도 있습니다. 이러한 방식으로 공격자의 채굴 파워가 네트워크의 쪼개진 채굴 파워보다 커지게 되면 쉽게 51% 공격을 개시할 수 있습니다.


## N - 컨펌 이중 지불(N-Confirmation Double Spending)
일반적으로 가게 주인이 물건을 팔고 송금을 받았을 때, 실제로 블록이 컨펌되기 전까지는 물건을 제공하지 않습니다. 블록이 재배열 될 수도 있기 때문입니다.

그러나, 이클립스 공격자에 의해 여러 채굴 노드들이 공격 대상이 되어 격리된 경우, 공격자는 자신의 트랜잭션을 이클립스 공격 대상인 채굴 노드에게 제공하여 블록체인에 추가하도록 합니다. 이 노드들은 이후에도 블록을 계속 생성하면서 공격자의 트랜잭션이 든 블록이 컨펌되도록 합니다.

이클립스 공격 대상이 된 가게 주인은 트랜잭션이 들어있는 블록이 컨펌되는 것을 보고 물건을 제공합니다. 이 후, 공격자가 격리된 노드들이 만든 블록체인을 전체 네트워크에 공유하면, 해당 블록체인의 노드들은 고아 블록이 되면서 트랜잭션 자체가 취소되게 됩니다.


# 이클립스 공격 대처 방법
## 무작위 노드 선택(Random Node Selection)
노드가 피어를 선택할 때 무작위가 아닌 경우, 공격자가 자신 주변의 노드를 공격 대상으로 선택할 수 있게 됩니다. 따라서 노드가 피어를 랜덤으로 선택하게 하여 공격자가 공격 대상 노드를 정하기 어렵도록 만들 수 있습니다.

## 정보 저장
노드가 다른 노드에 대한 정보를 기억하도록 하면, 해당 노드가 네트워크를 떠났다가 재접속 했을 때 이전에 연결했던 정직한 노드와 연결하여 정직한 피어 관계를 지속할 수 있습니다.

## 연결 수 늘리기
하나의 노드에 연결된 피어의 갯수를 늘리면, 노드가 정직한 노드에게 연결될 가능성 역시 높아집니다.

--- 


## 크립토재킹 공격
### 크립토재킹이란?
크립토재킹(Cryptojacking)은 감염된 피해자의 장치를 사용해 암호화폐를 채굴하는 것을 의미합니다. 공격자는 악성 채굴 프로그램을 사용하도록 유도하여, 해당 프로그램을 실행하면 악성 프로그램에 감염 되어 눈치채지 못할 만큼 시스템 자원을 이용해 채굴을 하게 됩니다. 감염된 피해자는 자신도 모르는 새에 채굴을 시작하고, 공격자는 피해자의 해시 파워를 사용해 채굴 보상을 받습니다. 암호화폐 채굴에는 많은 해시 파워가 필요하기 때문에 공격자들은 최대한 많은 피해자를 감염시켜, 저위험, 저비용으로 채굴을 위한 컴퓨터 자원을 모읍니다.

초창기 악성 채굴 프로그램은 악성 링크나 이메일 첨부 파일을 눌렀을 때 감염되도록 하였지만, 오늘날에는 보다 정교한 악성 채굴 프로그램이 개발되었습니다. 현재 대부분의 악성 채굴 프로그램은 웹 사이트 스크립트를 통해 실행됩니다. 이를 웹 기반 크립토재킹이라고 합니다.

크립토재킹은 랜섬웨어 등과 같이 컴퓨터 내 데이터를 손상시키지는 않습니다. 다만 크립토재킹은 컴퓨터로 채굴을 하기 때문에 CPU의 성능을 저하시킵니다.


## 웹 기반 크립토재킹
웹 기반 크립토재킹은 웹 사이트 내에서 실행되는 스크립트를 통해 악성 채굴 프로그램을 실행하며, 사용자가 웹 사이트에 머물러 있는 동안 브라우저를 통해 자동으로 채굴을 하도록 합니다. 웹 기반 크립토재킹은 보통 모네로(Monero)를 많이 채굴합니다. 모네로는 채굴을 위해 많은 해시 파워를 필요로 하지 않으며, 프라이버시와 익명성의 수준이 높아 거래를 추적하는 것이 어렵기 때문입니다.


## 코인하이브
코인하이브(CoinHive)는 웹 기반 크립토재킹을 최초로 구현하였습니다. 코인하이브는 자바스크립트로 채굴을 할 수 있도록 구성되어 있습니다. 코인하이브의 초창기 목적은 악성 채굴 프로그램이 아니라, 웹사이트 소유자들이 광고가 아닌 채굴을 통해 수익을 얻을 수 있도록 하는 것이었습니다.

코인하이브는 대부분의 브라우저와 호환이 되며, 배포 역시 쉽습니다. 코인하이브를 사용하면 채굴 수익의 30%를 가져갑니다.

그러나 코인하이브는 그 목적과는 다르게, 해커들이 여러 웹사이트를 해킹하여 코인하이브를 통해 웹사이트 소유자나 사용자의 허락 없이 채굴을 하도록 만들기 위해 사용되기 시작하면서 많은 비난을 받았습니다.

오늘날 코인하이브는 보안 감지 프로그램에 의해 쉽게 확인되기 때문에 위협적이지는 않지만, 코인하이브의 배포와 적용이 쉽기 때문에 주의를 기울여야 합니다.


## 더스팅 공격
### 더스팅 공격이란?
더스팅 공격(Dusting Attack)은 해커들이 아주 적은 양의 코인을 사용자의 지갑에 전송하여 사용자의 신원을 파악하는 악성 공격입니다.

먼저 더스트(Dust)는 아주 적은 양의 코인이나 토큰을 의미합니다. 가령 비트코인의 가장 작은 단위는 1 사토시로, 환산하면 0.00000001BTC입니다. 수백 사토시 정도를 더스트라고 부릅니다. 더스트는 가치 자체가 거의 없다보니, 일반적인 지갑 사용자들은 이 더스트들은 잘 신경쓰지 않습니다.

해커들은 일반 사용자들이 더스트 수준의 작은 금액에는 관심을 두지 않는다는 것을 악용합니다. 먼저 일반 사용자들의 주소로 더스트 수준의 적은 금액을 보내 많은 주소를 "더스팅(Dusting)" 합니다. 그리고 나서 해당 송금 트랜잭션과 더스팅된 지갑들의 트랜잭션을 추적합니다. 이 트랜잭션을 추적하다보면, 결국 지갑을 소유한 개인이 누구인지 알수 있습니다.

블록체인은 탈중앙화 되어있고 주소 기반이기 때문에 익명성이 보장됩니다. 그러나 대부분의 사람들은 거래소를 이용하며, 개인 지갑과 거래소 지갑을 연결시킵니다. 따라서 거래소 지갑에 있는 사용자의 개인 정보가 개인 지갑에도 연결되게 됩니다. 이러한 방식으로 해커들은 익명 사용자의 개인 정보를 파악합니다.

2018년 10월, 비트코인 사무라이(Bitcoin Samurai) 지갑 개발자들은 일부 사용자들이 더스팅 공격을 받고 있다고 발표했습니다. 비트코인 사무라이는 더스팅 추적을 실시간으로 알려주는 등 사용자가 더스팅 공격을 받고 있음을 인지시켜 사용자가 의심스러운 자금을 걸러내 트랜잭션에 더스트 자금을 사용하지 않을 수 있도록 지원했습니다.


## 시빌 공격
### 시빌 공격이란?
시빌 공격은 한 개인이 네트워크의 여러 노드를 장악하려는 악성 공격입니다. 

공격자는 충분한 수의 가짜 노드를 생성하여, 기존의 신뢰할 수 있는 노드를 네트워크에서 제외시킵니다. 이를 통해 블록을 수신하거나 전송하는 것을 거부하거나, 다른 노드들을 네트워크에서 차단할 수도 있습니다. 공격자가 네트워크 전체의 해시 파워를 넘는 대규모 시빌 공격을 하는 경우에는 51% 공격도 함께 발생할 수 있습니다.


### 시빌 공격에 대한 대응
많은 블록체인은 다양한 합의 알고리즘을 이용해 시빌 공격을 방어합니다. 그러나 합의 알고리즘은 시빌 공격을 원천적으로 봉쇄하기 보다는, 시빌 공격에 대한 비용 대비 수익보다 정상적인 채굴을 통한 비용 대비 수익을 더 크게 만들어, 시빌 공격 자체를 비효율적인 것으로 만듭니다.

가령, 작업 증명 방식에서는 새로운 블록 형성을 위해 특정한 규칙들을 가지고 있습니다. 규칙 중 하나는 블록을 생성하는 능력이 작업 증명 방식 메커니즘의 전체 프로세싱 파워와 비례해야 한다는 것입니다. 이는 새로운 블록을 생성하는데 필요한 컴퓨터 파워를 실제로 소유해야 함을 의미하며, 공격자가 많은 비용을 지불하여 해시 파워를 올려야 하기 때문에 공격을 감행하기가 매우 어렵습니다.

지분 증명 방식에서는 작업 증명 방식과는 다르게 물리적 자원이 아닌 경제적 자원을 사용해야 합니다. 지분 증명 방식에서는 채굴을 하기 위해서는 압도적으로 많은 양의 자산을 블록체인에 스테이킹 해야 하기 때문에, 시빌 공격을 했을 시 스테이킹 된 자신의 자산을 돌려받지 못할 수도 있습니다.

---

## The DAO
DAO는 블록체인 기반의 협동 조직으로, 코드로 규칙을 설정하고 실행합니다. DAO는 중앙 집중식 통제 구조를 투자자-이해당사자에 의해 결정되는 기술민주적인(Techno-Democratic) 접근법으로 대체합니다.

The DAO는 DAO 거버넌스의 초기 구현체이며, 오늘날 DEFi 플랫폼과 같은 블록체인 서비스들에 큰 영향을 미치고 있습니다.

## The DAO 해킹
이 공격에서 공격자는 트랜잭션 이후 DAO의 스마트 컨트랙트가 잔액을 업데이트 하기 전에 이더를 반환하도록 요청을 할 수 있었습니다. 이 요청이 가능했던 이유에는 두가지가 있습니다.

1. DAO 스마트 컨트랙트를 만든 개발자들이 재귀적 호출 가능성을 고려하지 않고 코드를 작성했기 때문입니다. 
2. 스마트 컨트랙트가 송금을 할 때, 자신이 가지고 있는 자금을 송금한 후에, 컨트랙트 내 잔액을 갱신하는 순서로 구성되어 있었다는 점 때문입니다. 

스마트 컨트랙트 자금을 송금한 후, 잔액을 갱신하기 전에 재귀적 호출을 하게 되면, 컨트랙트는 계속 자금을 송금하기만 하고 잔액을 갱신하지 않게 됩니다.

---

## 패리티 멀티시그 지갑 동결 사건
### 패리티 멀티시그 지갑이란?
이더리움의 공동 설립자이자 CTO인 개빈 우드(Gavin Wood)는 이더리움 인프라를 위한 소프트웨어를 개발하는 비영리 단체인 EthCore를 설립하면서 시작했으며, 후에 패리티 테크놀로지(Parity Technologies)로 이름을 변경하였습니다. 패리티 사의 주요 소프트웨어인 패리티는 이더리움 노드 소프트웨어를 위한 웹 인터페이스를 제공하는 이더리움 클라이언트입니다. 패리티에서 사용자는 일반적인 이더 및 기타 토큰 지갑 기능을 사용할 수도 있으며, 이더리움 블록체인에 구축된 스마트 컨트랙트와도 상호작용 할 수 있습니다. 패리티 지갑은 이더 전송을 관리하고, 모든 표준 토큰과 완벽하게 통합되도록 설계되었습니다.


### 패리티 멀티시그 지갑 동결
멀티시그는 스마트 컨트랙트 소스코드의 형태로 사용자에게 배포됩니다. 누군가가 이 스마트 컨트랙트를 가지고 싶을 때는 레포지토리에서 최신 코드를 가져와 이더리움 블록체인에 해당 컨트랙트를 배포하고, 다음 소유자를 설정하고, 자금을 배치하는 방식입니다. 각 지갑은 이 소스코드의 개별 인스턴스가 됩니다.

패리티의 경우, 자금을 인출할 수 있는 인출 함수 등과 같은 스마트 컨트랙트의 필수적인 로직들은 WalletLibrary라는 이름의 라이브러리에 있습니다. 이 라이브러리는 패리티 멀티시그가 사용하는 스마트 컨트랙트에 기본으로 들어가있습니다. 라이브러리를 사용한 코드 분리는 가스 수수료를 절감하는 등의 장점도 있지만, 라이브러리에 결함이 있다면, 해당 라이브러리를 사용하는 모든 컨트랙트에 영향을 미치게 됩니다.

2017년 11월 6일 한 공격자가 라이브러리를 지갑화하여 해당 지갑을 파괴하는 공격이 벌어졌습니다. 이 공격으로 인해 라이브러리 그 자체를 하나의 지갑으로 초기화하는 것이 가능하고, 지갑화된 라이브러리의 소유자는 해당 지갑을 파괴할(Kill) 권한을 가지게 된다는 것이 밝혀졌습니다. 악의적인 공격자가 라이브러리를 지갑으로 만든후 파괴하면서, 라이브러리를 사용하는 모든 컨트랙트가 무용지물이 되어버렸습니다.

WalletLibrary가 배포된 이후 생성된 멀티시그 지갑들은 동결되었습니다. 이 지갑들은 총 587개이며, 총 513,774.16 ETH(오늘날 한화 약 2조 7천억 원)가 동결되었습니다. 이로 인해 패리티 멀티시그 지갑을 사용해 ICO 자금을 보관하던 폴카닷(Polkadot)과 같은 회사들의 자금 역시 동결되었습니다.

---